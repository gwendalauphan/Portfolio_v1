variables:
  DOCKER_HOST: tcp://docker:2375/
  DOCKER_TLS_CERTDIR: ""
  PORTFOLIO_V1_GROUP_REGISTRY: registry.gitlab.com/web6464113
  PORTFOLIO_V1_REPO_NAME: "portfolio_v1"
  ENV_DEPLOYMENT: "dev"
  PORTFOLIO_V1_IMAGE_NAME: "portfolio_v1-app-builder"
  PORTFOLIO_V1_TAG: "latest"
  BUILD_IMAGE: "${PORTFOLIO_V1_GROUP_REGISTRY}/${PORTFOLIO_V1_REPO_NAME}/${ENV_DEPLOYMENT}/${PORTFOLIO_V1_IMAGE_NAME}:${PORTFOLIO_V1_TAG}"
  NODE_VERSION: "18"
  SHARED_ENV_FILE: deploy_inputs.env
  VARIABLES_MANAGMENT_PROJECT_ID: "68617213"

include:
  - local: .ci/common.yml
  - local: .ci/update_variable_managment_manual.yml
  - local: .ci/detect_changes.yml

stages:
  - trigger
  - debug
  - detect_changes
  - test
  - build
  - deploy

debug:
  stage: debug
  script:
    - |
      source ./docker/.env
      echo "LOCAL_WEBAPP_DIR: $LOCAL_WEBAPP_DIR"
      echo "BUILD_IMAGE: $BUILD_IMAGE"
      echo "NODE_VERSION: $NODE_VERSION"
      echo "User: $CI_REGISTRY_USER"
      echo "Registry: $CI_REGISTRY"
  rules:
    - if: '$CI_COMMIT_MESSAGE =~ /(\[debug:true\])/'
      when: always
    - when: never

test:
  stage: test
  image: node:${NODE_VERSION}
  needs:
    - job: conditional_run_npm_test
  only:
    - merge_requests
    - branches
    - tags
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - app/node_modules/
  script:
    - cd app
    - node -v
    - npm ci
    #- npm run lint
    #- npm run test
    - npm run build

test-skipped:
  stage: test
  image: alpine:latest
  when: on_failure
  only:
    - merge_requests
    - branches
    - tags
  script:
    - echo "No test to run, skipping"
  rules:


.before_docker_login: &before_docker_login
  before_script:
    - export COMPOSE_BAKE=true
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin

build:
  stage: build
  image: docker:latest
  needs:
    - job: test
      optional: true
    - job: conditional_run_docker_test
  
  services:
    - docker:dind
  <<: *before_docker_login
  script:
    # if tag and branch == main
    # check if image already exists
    # if not, build and push
    # if yes, skip build and push
    - touch $SHARED_ENV_FILE
    - |
      if [[ "$CI_COMMIT_TAG" ]]; then
        #check if image already exists
        ENV_DEPLOYMENT="prd"
        IMAGE_TAG="${PORTFOLIO_V1_GROUP_REGISTRY}/${PORTFOLIO_V1_REPO_NAME}/${ENV_DEPLOYMENT}/${PORTFOLIO_V1_IMAGE_NAME}:${CI_COMMIT_TAG}"
        echo "IMAGE_TAG: ${IMAGE_TAG}"
        echo "Checking if image already exists..."
        if docker pull "${IMAGE_TAG}"; then
          echo "Image already exists, skipping build and push"
          exit 0
        else
          echo "Image does not exist, building and pushing"
        fi
      fi
    - echo "Build image"
    - docker compose -f docker/docker-compose.yml build --pull
    - echo "Run containers for standalone"
    - docker compose -f standalone/docker-compose.yml up -d
    #- immplement /healthz
    - docker compose -f standalone/docker-compose.yml down

    - echo "=== Variables debug ==="
    - echo "CI_PIPELINE_SOURCE  = $CI_PIPELINE_SOURCE"
    - echo "CI_COMMIT_BRANCH    = $CI_COMMIT_BRANCH"
    - echo "CI_COMMIT_MESSAGE   = <$CI_COMMIT_MESSAGE>"

    - |
      echo "=== Choix de la condition d'envoi d'image ==="

      if [[ "$CI_COMMIT_MESSAGE" == *"\[build:image\]"* ]] && [[ "$CI_COMMIT_BRANCH" != "main" ]]; then
        echo "Condition 1: [build:image] détecté et branch != main"
        echo "→ On pousse directement l'image: ${BUILD_IMAGE}"
        
        ENV_DEPLOYMENT="dev"
        PORTFOLIO_V1_TAG="${CI_COMMIT_SHORT_SHA}"
        TARGET_IMAGE="${PORTFOLIO_V1_GROUP_REGISTRY}/${PORTFOLIO_V1_REPO_NAME}/${ENV_DEPLOYMENT}/${PORTFOLIO_V1_IMAGE_NAME}:${PORTFOLIO_V1_TAG}"

        docker tag "${BUILD_IMAGE}" "${TARGET_IMAGE}"
        docker push "${TARGET_IMAGE}"
        docker push "${BUILD_IMAGE}"

        echo "REGISTRY_IMAGE=${TARGET_IMAGE}" > $SHARED_ENV_FILE
        echo "PROJECT_NAME=${PORTFOLIO_V1_REPO_NAME}" >> $SHARED_ENV_FILE
        echo "ENV_DEPLOYMENT=${ENV_DEPLOYMENT}" >> $SHARED_ENV_FILE
        cat $SHARED_ENV_FILE

      elif [[ "$CI_COMMIT_BRANCH" == "main" ]]; then
        echo "Condition 2: branch == main"
        echo "-> On retag l'image avant de la pousser"
        
        ENV_DEPLOYMENT="prd"
        PORTFOLIO_V1_TAG="${CI_COMMIT_SHORT_SHA}"
        TARGET_IMAGE="${PORTFOLIO_V1_GROUP_REGISTRY}/${PORTFOLIO_V1_REPO_NAME}/${ENV_DEPLOYMENT}/${PORTFOLIO_V1_IMAGE_NAME}:${PORTFOLIO_V1_TAG}"
        TARGET_IMAGE_LATEST="${PORTFOLIO_V1_GROUP_REGISTRY}/${PORTFOLIO_V1_REPO_NAME}/${ENV_DEPLOYMENT}/${PORTFOLIO_V1_IMAGE_NAME}:latest"
        
        docker tag "${BUILD_IMAGE}" "${TARGET_IMAGE}"
        docker tag "${BUILD_IMAGE}" "${TARGET_IMAGE_LATEST}"
        docker push "${TARGET_IMAGE}"
        docker push "${TARGET_IMAGE_LATEST}"

      elif [[ "$CI_COMMIT_TAG" ]]; then
        git fetch origin main
        echo "Checking if commit $CI_COMMIT_SHA is reachable from main branch"
        is_from_main=$(git rev-list origin/main | grep -w "$CI_COMMIT_SHA" || echo "false")
        is_from_main=$(if [ $is_from_main = "false" ]; then echo "false"; else echo "true"; fi)
        if [ "$is_from_main" = "true" ]; then
          echo "Condition 3: branch == main et tag"
          PORTFOLIO_V1_TAG="${CI_COMMIT_SHORT_SHA}"
          TARGET_IMAGE="${PORTFOLIO_V1_GROUP_REGISTRY}/${PORTFOLIO_V1_REPO_NAME}/${ENV_DEPLOYMENT}/${PORTFOLIO_V1_IMAGE_NAME}:${PORTFOLIO_V1_TAG}"
          docker tag "${BUILD_IMAGE}" "${TARGET_IMAGE}"
          docker push "${TARGET_IMAGE}"
        else
          echo "Tag not created on main branch, skipping push"
        fi
      else
        echo "Condition 4: Aucune condition remplie"
        echo "Skipping image push : pas de [build:image], pas de main, pas de nouveau tag."
      fi
      echo "==== Fin du push d'image ===="

  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: always
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_MESSAGE =~ /(\[build:image\])/'
      when: always
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH == "main"'
      when: always
    - if: '$CI_COMMIT_TAG'
      when: always
    - when: never
  artifacts:
    paths:
      - $SHARED_ENV_FILE
    expire_in: 1 hour
    when: always

push-tag:
  stage: deploy
  image: docker:latest
  needs:
    - build
  rules:
    - if: '$CI_COMMIT_TAG'
      when: always
    - when: never
  services:
    - docker:dind
  <<: *before_docker_login
  script:
    - |
      touch $SHARED_ENV_FILE
      git fetch origin main
      echo "Checking if commit $CI_COMMIT_SHA is reachable from main branch"
      is_from_main=$(git rev-list origin/main | grep -w "$CI_COMMIT_SHA" || echo "false")
      is_from_main=$(if [ $is_from_main = "false" ]; then echo "false"; else echo "true"; fi)
        if [ "$is_from_main" = "true" ]; then
        echo "OK : le tag actuel est issu d'un commit présent dans 'main'";
      else
        echo "ERREUR : ce tag n'a pas été créé sur la branche 'main'.";
        exit 1;
      fi
      if [[ ! "$CI_COMMIT_TAG" =~ ^v[0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,2}$ ]]; then
        echo "ERREUR : le tag '$CI_COMMIT_TAG' ne respecte pas le format requis '^v[0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,2}$'.";
        exit 1;
      fi

      echo "-> On retag l'image avant de la pousser"
      ENV_DEPLOYMENT="prd"
      PORTFOLIO_V1_TAG="${CI_COMMIT_TAG}"
      COMMIT_SHA_MAIN=${CI_COMMIT_SHORT_SHA}
      echo "COMMIT_SHA_MAIN: ${COMMIT_SHA_MAIN}"

      IMAGE_TAG_MAIN="${PORTFOLIO_V1_GROUP_REGISTRY}/${PORTFOLIO_V1_REPO_NAME}/${ENV_DEPLOYMENT}/${PORTFOLIO_V1_IMAGE_NAME}:${COMMIT_SHA_MAIN}"
      TARGET_IMAGE="${PORTFOLIO_V1_GROUP_REGISTRY}/${PORTFOLIO_V1_REPO_NAME}/${ENV_DEPLOYMENT}/${PORTFOLIO_V1_IMAGE_NAME}:${PORTFOLIO_V1_TAG}"
      TARGET_IMAGE_LATEST="${PORTFOLIO_V1_GROUP_REGISTRY}/${PORTFOLIO_V1_REPO_NAME}/${ENV_DEPLOYMENT}/${PORTFOLIO_V1_IMAGE_NAME}:latest"

      docker pull "${IMAGE_TAG_MAIN}"
      docker tag "${IMAGE_TAG_MAIN}" "${TARGET_IMAGE}"
      docker tag "${IMAGE_TAG_MAIN}" "${TARGET_IMAGE_LATEST}"
     
      
      docker push "${TARGET_IMAGE}"
      docker push "${TARGET_IMAGE_LATEST}"

    - echo "REGISTRY_IMAGE=${TARGET_IMAGE}" > $SHARED_ENV_FILE
    - echo "PROJECT_NAME=${PORTFOLIO_V1_REPO_NAME}" >> $SHARED_ENV_FILE
    - echo "ENV_DEPLOYMENT=${ENV_DEPLOYMENT}" >> $SHARED_ENV_FILE
    - cat $SHARED_ENV_FILE
  artifacts:
    paths:
      - $SHARED_ENV_FILE
    expire_in: 1 hour
    when: always


update-variable-managment-from-tag:
  stage: deploy
  before_script:
    - source $SHARED_ENV_FILE
  extends: .update-variable-managment-template
  needs:
    - job: push-tag
      artifacts: true
  rules:
    - if: '$CI_COMMIT_TAG'
      when: on_success
      allow_failure: false

update-variable-managment-from-build:
  stage: deploy
  before_script:
    - source $SHARED_ENV_FILE
  extends: .update-variable-managment-template
  needs:
    - job: build
      artifacts: true
  rules:
    # Déclenchement sur branche different de main avec [build:image]
    - if: '$CI_COMMIT_BRANCH != "main" && $CI_COMMIT_MESSAGE =~ /(\[build:image\])/'
      when: on_success
      allow_failure: false


