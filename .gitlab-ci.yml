variables:
  DOCKER_HOST: tcp://docker:2375/
  DOCKER_TLS_CERTDIR: ""
  PORTFOLIO_V1_GROUP_REGISTRY: registry.gitlab.com/web6464113
  PORTFOLIO_V1_REPO_NAME: "portfolio_v1"
  ENV_DEPLOYMENT: "dev"
  PORTFOLIO_V1_IMAGE_NAME: "portfolio_v1-app-builder"
  PORTFOLIO_V1_TAG: "latest"
  BUILD_IMAGE: "${PORTFOLIO_V1_GROUP_REGISTRY}/${PORTFOLIO_V1_REPO_NAME}/${ENV_DEPLOYMENT}/${PORTFOLIO_V1_IMAGE_NAME}:${PORTFOLIO_V1_TAG}"
  NODE_VERSION: "18"
  SHARED_ENV_FILE: deploy_inputs.env
  VARIABLES_MANAGMENT_PROJECT_ID: "68617213"


stages:
  - trigger
  - debug
  - test
  - build
  - deploy

debug:
  stage: debug
  script:
    - |
      source ./docker/.env
      echo "LOCAL_WEBAPP_DIR: $LOCAL_WEBAPP_DIR"
      echo "BUILD_IMAGE: $BUILD_IMAGE"
      echo "NODE_VERSION: $NODE_VERSION"
      echo "User: $CI_REGISTRY_USER"
      echo "Registry: $CI_REGISTRY"
  rules:
    - if: '$CI_COMMIT_MESSAGE =~ /(\[debug:true\])/'
      when: always
    - when: never

  
test:
  stage: test
  image: node:${NODE_VERSION}
  only:
    - merge_requests
    - branches
    - tags
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - app/node_modules/
  script:
    - cd app
    - node -v
    - npm ci
    #- npm run lint
    #- npm run test
    - npm run build

.before_docker_login: &before_docker_login
  before_script:
    - export COMPOSE_BAKE=true
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin

build:
  stage: build
  image: docker:latest
  needs:
    - test
  services:
    - docker:dind
  <<: *before_docker_login
  script:
    # if tag and branch == main
    # check if image already exists
    # if not, build and push
    # if yes, skip build and push
    - touch $SHARED_ENV_FILE
    - |
      if [[ "$CI_COMMIT_TAG" ]]; then
        #check if image already exists
        ENV_DEPLOYMENT="prd"
        IMAGE_TAG="${PORTFOLIO_V1_GROUP_REGISTRY}/${PORTFOLIO_V1_REPO_NAME}/${ENV_DEPLOYMENT}/${PORTFOLIO_V1_IMAGE_NAME}:${CI_COMMIT_TAG}"
        echo "IMAGE_TAG: ${IMAGE_TAG}"
        echo "Checking if image already exists..."
        if docker pull "${IMAGE_TAG}"; then
          echo "Image already exists, skipping build and push"
          exit 0
        else
          echo "Image does not exist, building and pushing"
        fi
      fi
    - echo "Build image"
    - docker compose -f docker/docker-compose.yml build --pull
    - echo "Run containers for standalone"
    - docker compose -f standalone/docker-compose.yml up -d
    #- immplement /healthz
    - docker compose -f standalone/docker-compose.yml down

    - echo "=== Variables debug ==="
    - echo "CI_PIPELINE_SOURCE  = $CI_PIPELINE_SOURCE"
    - echo "CI_COMMIT_BRANCH    = $CI_COMMIT_BRANCH"
    - echo "CI_COMMIT_MESSAGE   = <$CI_COMMIT_MESSAGE>"

    - |
      echo "=== Choix de la condition d'envoi d'image ==="

      if [[ "$CI_COMMIT_MESSAGE" == *"\[build:image\]"* ]] && [[ "$CI_COMMIT_BRANCH" != "main" ]]; then
        echo "Condition 1: [build:image] détecté et branch != main"
        echo "→ On pousse directement l'image: ${BUILD_IMAGE}"
        
        ENV_DEPLOYMENT="dev"
        PORTFOLIO_V1_TAG="${CI_COMMIT_SHORT_SHA}"
        TARGET_IMAGE="${PORTFOLIO_V1_GROUP_REGISTRY}/${PORTFOLIO_V1_REPO_NAME}/${ENV_DEPLOYMENT}/${PORTFOLIO_V1_IMAGE_NAME}:${PORTFOLIO_V1_TAG}"

        docker tag "${BUILD_IMAGE}" "${TARGET_IMAGE}"
        docker push "${TARGET_IMAGE}"
        docker push "${BUILD_IMAGE}"

        echo "REGISTRY_IMAGE=${TARGET_IMAGE}" > $SHARED_ENV_FILE
        echo "PROJECT_NAME=${PORTFOLIO_V1_REPO_NAME}" >> $SHARED_ENV_FILE
        echo "ENV_DEPLOYMENT=${ENV_DEPLOYMENT}" >> $SHARED_ENV_FILE
        cat $SHARED_ENV_FILE

      elif [[ "$CI_COMMIT_BRANCH" == "main" ]]; then
        echo "Condition 2: branch == main"
        echo "-> On retag l'image avant de la pousser"
        
        ENV_DEPLOYMENT="prd"
        PORTFOLIO_V1_TAG="${CI_COMMIT_SHORT_SHA}"
        TARGET_IMAGE="${PORTFOLIO_V1_GROUP_REGISTRY}/${PORTFOLIO_V1_REPO_NAME}/${ENV_DEPLOYMENT}/${PORTFOLIO_V1_IMAGE_NAME}:${PORTFOLIO_V1_TAG}"
        TARGET_IMAGE_LATEST="${PORTFOLIO_V1_GROUP_REGISTRY}/${PORTFOLIO_V1_REPO_NAME}/${ENV_DEPLOYMENT}/${PORTFOLIO_V1_IMAGE_NAME}:latest"
        
        docker tag "${BUILD_IMAGE}" "${TARGET_IMAGE}"
        docker tag "${BUILD_IMAGE}" "${TARGET_IMAGE_LATEST}"
        docker push "${TARGET_IMAGE}"
        docker push "${TARGET_IMAGE_LATEST}"

      elif [[ "$CI_COMMIT_TAG" ]]; then
        if git merge-base --is-ancestor "origin/main" HEAD; then
          echo "Condition 3: branch == main et tag"
          PORTFOLIO_V1_TAG="${CI_COMMIT_SHORT_SHA}"
          TARGET_IMAGE="${PORTFOLIO_V1_GROUP_REGISTRY}/${PORTFOLIO_V1_REPO_NAME}/${ENV_DEPLOYMENT}/${PORTFOLIO_V1_IMAGE_NAME}:${PORTFOLIO_V1_TAG}"
          docker tag "${BUILD_IMAGE}" "${TARGET_IMAGE}"
          docker push "${TARGET_IMAGE}"
        else
          echo "Tag not created on main branch, skipping push"
        fi
      else
        echo "Condition 4: Aucune condition remplie"
        echo "Skipping image push : pas de [build:image], pas de main, pas de nouveau tag."
      fi
      echo "==== Fin du push d'image ===="

  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: always
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_MESSAGE =~ /(\[build:image\])/'
      when: always
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH == "main"'
      when: always
    - if: '$CI_COMMIT_TAG'
      when: always
    - when: never
  artifacts:
    paths:
      - $SHARED_ENV_FILE
    expire_in: 1 hour
    when: always

push-tag:
  stage: deploy
  image: docker:latest
  needs:
    - build
  rules:
    - if: '$CI_COMMIT_TAG'
      when: always
    - when: never
  services:
    - docker:dind
  <<: *before_docker_login
  script:
    - |
      touch $SHARED_ENV_FILE
      if git merge-base --is-ancestor "origin/main" HEAD; then
        echo "OK : le tag actuel est issu d'un commit présent dans 'main'";
      else
        echo "ERREUR : ce tag n'a pas été créé sur la branche 'main'.";
        exit 1;
      fi
      if [[ ! "$CI_COMMIT_TAG" =~ ^v[0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,2}$ ]]; then
        echo "ERREUR : le tag '$CI_COMMIT_TAG' ne respecte pas le format requis '^v[0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,2}$'.";
        exit 1;
      fi

      echo "-> On retag l'image avant de la pousser"
      ENV_DEPLOYMENT="prd"
      PORTFOLIO_V1_TAG="${CI_COMMIT_TAG}"
      COMMIT_SHA_MAIN=${CI_COMMIT_SHORT_SHA}
      echo "COMMIT_SHA_MAIN: ${COMMIT_SHA_MAIN}"

      IMAGE_TAG_MAIN="${PORTFOLIO_V1_GROUP_REGISTRY}/${PORTFOLIO_V1_REPO_NAME}/${ENV_DEPLOYMENT}/${PORTFOLIO_V1_IMAGE_NAME}:${COMMIT_SHA_MAIN}"
      TARGET_IMAGE="${PORTFOLIO_V1_GROUP_REGISTRY}/${PORTFOLIO_V1_REPO_NAME}/${ENV_DEPLOYMENT}/${PORTFOLIO_V1_IMAGE_NAME}:${PORTFOLIO_V1_TAG}"
      TARGET_IMAGE_LATEST="${PORTFOLIO_V1_GROUP_REGISTRY}/${PORTFOLIO_V1_REPO_NAME}/${ENV_DEPLOYMENT}/${PORTFOLIO_V1_IMAGE_NAME}:latest"

      docker pull "${IMAGE_TAG_MAIN}"
      docker tag "${IMAGE_TAG_MAIN}" "${TARGET_IMAGE}"
      docker tag "${IMAGE_TAG_MAIN}" "${TARGET_IMAGE_LATEST}"
     
      
      docker push "${TARGET_IMAGE}"
      docker push "${TARGET_IMAGE_LATEST}"

    - echo "REGISTRY_IMAGE=${TARGET_IMAGE}" > $SHARED_ENV_FILE
    - echo "PROJECT_NAME=${PORTFOLIO_V1_REPO_NAME}" >> $SHARED_ENV_FILE
    - echo "ENV_DEPLOYMENT=${ENV_DEPLOYMENT}" >> $SHARED_ENV_FILE
    - cat $SHARED_ENV_FILE
  artifacts:
    paths:
      - $SHARED_ENV_FILE
    expire_in: 1 hour
    when: always

.update-variable-managment-template: &update-variable-managment-template
  script:
    - |
      echo "Déploiement du projet : $PROJECT_NAME"
      echo "Image utilisée : $REGISTRY_IMAGE"
      echo "Environnement : $ENV_DEPLOYMENT"
      if [[ -z "$REGISTRY_IMAGE" || -z "$PROJECT_NAME" || -z "$ENV_DEPLOYMENT" ]]; then
        echo "Erreur : une ou plusieurs variables d'environnement sont vides."
        exit 1
      fi
      curl -X POST --fail \
      -F token=$CI_JOB_TOKEN \
      -F ref=main \
      -F "variables[REGISTRY_IMAGE]=$REGISTRY_IMAGE" \
      -F "variables[PROJECT_NAME]=$PROJECT_NAME" \
      -F "variables[ENV_DEPLOYMENT]=$ENV_DEPLOYMENT" \
      https://gitlab.com/api/v4/projects/$VARIABLES_MANAGMENT_PROJECT_ID/trigger/pipeline


trigger-variable-managment-from-manual:
  stage: trigger
  variables:
    description: "REGISTRY_IMAGE"
    value: ""
    PROJECT_NAME:
      value: ""
    ENV_DEPLOYMENT:
      value: ""
  rules:
    - when: manual
      allow_failure: true
  <<: *update-variable-managment-template

update-variable-managment-from-tag:
  stage: deploy
  before_script:
    - source $SHARED_ENV_FILE
  <<: *update-variable-managment-template
  needs:
    - job: push-tag
      artifacts: true
  rules:
    - if: '$CI_COMMIT_TAG'
      when: on_success
      allow_failure: false

update-variable-managment-from-build:
  stage: deploy
  before_script:
    - source $SHARED_ENV_FILE
  <<: *update-variable-managment-template
  needs:
    - job: build
      artifacts: true
  rules:
    # Déclenchement sur branche different de main avec [build:image]
    - if: '$CI_COMMIT_BRANCH != "main" && $CI_COMMIT_MESSAGE =~ /(\[build:image\])/'
      when: on_success
      allow_failure: false


